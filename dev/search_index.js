var documenterSearchIndex = {"docs":
[{"location":"PolyExp/#PolyExp","page":"PolyExp","title":"PolyExp","text":"","category":"section"},{"location":"PolyExp/","page":"PolyExp","title":"PolyExp","text":"FEBULIA.PolyExp\nFEBULIA.shift_PolyExp\nFEBULIA.evalPolyExp\nFEBULIA.PolyExpBasisFun\nFEBULIA.deriv\nFEBULIA.polynomial_primitive\nFEBULIA.polynomial_deriv\nFEBULIA.integrate","category":"page"},{"location":"PolyExp/#FEBULIA.PolyExp","page":"PolyExp","title":"FEBULIA.PolyExp","text":"PolyExp\n\nObject that represents exponential-polynomials of the form ``P(X) = e^{\\alpha X}\\underset{n=0}{\\overset{N}{\\sum}} c_{N-n+1} X^n``\n\nAn object can be created with PolyExp(nn::Int64,cc::Array{Cdouble,1},``\\alpha``::Cdouble)\n\n``c = [1.0; 2.0; 3.0; 4.0]``\n``\\alpha = 0.7``\nN = 3\n\np = PolyExp(N,c,``\\alpha``)\n\nPolyExp object can be multiplied * and compare ==\n\n\n\n\n\n","category":"type"},{"location":"PolyExp/#FEBULIA.shift_PolyExp","page":"PolyExp","title":"FEBULIA.shift_PolyExp","text":"shift_PolyExp(P::PolyExp,x0::Cdouble,x1::Cdouble;rev::Bool=false)\n\na function that computes the coefficient of a PolyExp when evaluated either in $\frac{X-x_0}{x_1-x_0}$ (rev=false) or in $\frac{x_1-X}{x_1-x_0}$ (rev=true)\n\nThe returned PolyExp P_shift(X) is the same degree as the input object\n\n\n\n\n\n","category":"function"},{"location":"PolyExp/#FEBULIA.evalPolyExp","page":"PolyExp","title":"FEBULIA.evalPolyExp","text":"evalPolyExp(x::Cdouble,p::PolyExp)\nevalPolyExp(x::Array{Cdouble,1},p::PolyExp)\n\nevaluates the PolyExp for the value x\n\n\n\n\n\n","category":"function"},{"location":"PolyExp/#FEBULIA.PolyExpBasisFun","page":"PolyExp","title":"FEBULIA.PolyExpBasisFun","text":"PolyExpBasisFun(x::Cdouble,xmin::Cdouble,xmed::Cdouble,xmax::Cdouble,PE1::PolyExp,PE2::PolyExp)\n\nevaluates in x the function defined as\n```\n\\begin{cases}\n    PE1(X) & \\text{ if } X\\in[x_{\\min},x_{\\text{med}})\\\\\n    PE2(X) & \\text{ if } X\\in[x_{\\text{med}},x_{\\max})\\\\\n    0 & \\text{otherwise}\n\\end{cases}\n```\n\n\n\n\n\n","category":"function"},{"location":"PolyExp/#FEBULIA.deriv","page":"PolyExp","title":"FEBULIA.deriv","text":"deriv(PE::PolyExp)\n\ncreates a PolyExp object that is the derivative of PE, $\frac{\text{d}PE}{\text{d}X}$\n\n\n\n\n\nderiv(BPE::basis_PE)\n\nreturns a new `basis_PE` object with the derivatives of each function in BPE\n\n\n\n\n\n","category":"function"},{"location":"PolyExp/#FEBULIA.polynomial_primitive","page":"PolyExp","title":"FEBULIA.polynomial_primitive","text":"polynomial_primitive(PE::PolyExp)\n\ncreates a PolyExp object with the primitive of the PolyExp PE, i.e. the exponential coefficient is 0, the degree of the polynomial is PE.n+1, and the constant term is 0\n\n\n\n\n\n","category":"function"},{"location":"PolyExp/#FEBULIA.polynomial_deriv","page":"PolyExp","title":"FEBULIA.polynomial_deriv","text":"polynomial_deriv(PE::PolyExp)\n\ncreates a PolyExp object with the derivative of the PolyExp PE, i.e. the exponential coefficient is 0 and the degree of the polynomial is PE.n-1\n\n\n\n\n\n","category":"function"},{"location":"PolyExp/#FEBULIA.integrate","page":"PolyExp","title":"FEBULIA.integrate","text":"integrate(PE::PolyExp,xmin::Cdouble,xmax::Cdouble)\n\ncompute recursively the integrale\n\nI_n^{\\alpha}(x_{\\min},x_{\\max}) = $\\int_{x_{\\min}}^{x_{\\max}} e^{\\alpha x} \\underset{n=0}{\\overset{N}{\\sum}} c_{N-n+1} X^n \\text{d}x$\n\nif \\alpha \\neq 0, then \n    I_n^{\\alpha}(x_{\\min},x_{\\max}) = \\frac{1}{\\alpha} \\left(R_{n}^{\\alpha}(x_{\\min},x_{\\max}) - I_{n-1}^{\\alpha}(x_{\\min},x_{\\max})\\right)\n    I_0^{\\alpha}(x_{\\min},x_{\\max}) = \\frac{R_{0}^{\\alpha}(x_{\\min},x_{\\max})}{\\alpha}\n\n    with R_{n}^{\\alpha}(x_{\\min},x_{\\max}) = [\\frac{\\text{d}^{(N-n)} Poly(PE)}{\\text{d} x}(x) e^{\\alpha x}]_{x_{\\min}}^{x_{\\max}} \n    where Poly(PE) is the polynomial part of the PolyExp object, and by convention, the zero-th order derivative is the function\n\nif \\alpha=0, then\n\n    I_n^{\\alpha}(x_{\\min},x_{\\max}) = R_{n}^{\\alpha}(x_{\\min},x_{\\max}) (as defined above)\n\n\n\n\n\n","category":"function"},{"location":"inner_products/#Inner-products","page":"Inner products","title":"Inner products","text":"","category":"section"},{"location":"inner_products/","page":"Inner products","title":"Inner products","text":"FEBULIA.riemann\nFEBULIA.dotf\nFEBULIA.compute_norm\nFEBULIA.coefficient","category":"page"},{"location":"inner_products/#FEBULIA.riemann","page":"Inner products","title":"FEBULIA.riemann","text":"riemann(f::Function, a::Real, b::Real, n::Int; method=\"right\") \n\nnumerical quadrature to compute the integral value of the function f over the interval [a,b] using n nodes\n\nriemann(fs::Array{Cdouble,1},xs::Array{Cdouble,1}; method=\"trapezoid\")\n\ncomputes the numerical integration of the function f whose values are passed in fs for the nodes xs (fs = f.(xs))\n\noptional argument\n\n    - method ∈ {\"right\",\"left\",\"trapezoid\",\"simpsons\"}\n\n    \"right\":     f(r) * (r-l)\n    \"left\":      f(l) * (r-l)\n    \"trapezoid\": (1/2) * (f(l) + f(r)) * (r-l)\n    \"simpsons\":  (1.0/6.0) * (f(l) + 4.0*(f((l+r)/2.0)) + f(r)) * (r-l)\n\n\n\n\n\n","category":"function"},{"location":"inner_products/#FEBULIA.dotf","page":"Inner products","title":"FEBULIA.dotf","text":"dotf(f::Function,g::Function,x_min::Cdouble,x_max::Cdouble;N::Int64=10000)\ndotf(f::Array{Cdouble,1},g::Array{Cdouble,1},x::Array{Cdouble,1})\n\nDot product for the functions f and g over the interval [x_min,x_max]\n\n    (f,g) = ∫ f(x)g(x) dx\n\nthe functions f and g can be passed as argument and will then be evaluated in N nodes in the interval [x_min,x_max]\nor the values can be passed in arrays f = f(x) and g = g(x)\n\n\n\n\n\n","category":"function"},{"location":"inner_products/#FEBULIA.compute_norm","page":"Inner products","title":"FEBULIA.compute_norm","text":"compute_norm(f::Function,x_min::Cdouble,x_max::Cdouble)\ncompute_norm(fs::Array{Cdouble,1},xs::Array{Cdouble,1})\n\nNorm of the function f over the interval [x_min,x_max]\n\n    ||f|| = √(∫(f(x))^2 dx)\n\nthe function f can be passed as argument and will then be evaluated in N nodes in the interval [x_min,x_max]\nor the values can be passed in an array f = f(x)\n\n\n\n\n\n","category":"function"},{"location":"inner_products/#FEBULIA.coefficient","page":"Inner products","title":"FEBULIA.coefficient","text":"coefficient(B::basis,f::Function)\n\ncomputes the coefficients of the projection of the function f onto the basis function of B \n    c_i = (2/(Δx)) * ∫ f(x)*B.v[i](x) dx\n\n\n\n\n\ncoefficient(B::basis_PE,f::Function)\n\ncomputes the coefficients of the projection of the function f onto the basis function of B \n    c_i = (2/(Δx)) * ∫ f(x)*B.v[i](x) dx\n\n\n\n\n\n","category":"function"},{"location":"#FEBULIA.jl","page":"Home","title":"FEBULIA.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FEBULIA.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"FEBULIA.FEBULIA\nFEBULIA.BoundCond1D\nFEBULIA.basis_PE_BC\nFEBULIA.basis_PE\nFEBULIA.basis","category":"page"},{"location":"#FEBULIA.FEBULIA","page":"Home","title":"FEBULIA.FEBULIA","text":"This is the FEBULIA, it contains \n\nFEBULIA.BoundCond1D\nFEBULIA.riemann\nFEBULIA.dotf\nFEBULIA.compute_norm\nFEBULIA.coefficient\nFEBULIA.PolyExp\nFEBULIA.shift_PolyExp\nFEBULIA.evalPolyExp\nFEBULIA.PolyExpBasisFun\nFEBULIA.deriv\nFEBULIA.polynomial_primitive\nFEBULIA.polynomial_deriv\nFEBULIA.integrate\nFEBULIA.basis_PE_BC\nFEBULIA.basis_PE\nFEBULIA.basis\n\n\n\n\n\n","category":"module"},{"location":"#FEBULIA.BoundCond1D","page":"Home","title":"FEBULIA.BoundCond1D","text":"BoundCond1D \n\nThis type contains all the necessary information related to the boundary conditions of a FE problem in 1D\n\n - BCl and BCu: strings describing the boundary conditions (valid type in {\"Dirichlet\", \"Neumann\", \"Robin\"})\n - xl and xu: are the boundaries (xl: low, xu: up)\n - ul and uu: values of the boundary conditions\n - g: a function that gives the values at the boundaries, it may vary with an external parameter which is why it is a function\n - a and b: describe the Robin conditions ($a u(x) + b \\frac{\\partial u}{\\partial x}(x) = g(x)$)\n\n An object is constructed with the function\n    \n    BoundCond1D(BCl::String,BCu::String,xl::Cdouble,xu::Cdouble;lowBC::Cdouble=0.0,upBC::Cdouble=0.0,Ra::Cdouble=0.0,Rb::Cdouble=0.0,Rg::Function=(y::Cdouble->0.0))\n\n\n\n\n\n","category":"type"},{"location":"#FEBULIA.basis_PE_BC","page":"Home","title":"FEBULIA.basis_PE_BC","text":"basis_PE_BC(X::Array{Cdouble,1},p1::PolyExp,p2::PolyExp,BC::BoundCond1D)\n\ngenerates a `basis_PE` object from\n\n  - X:         array with N discretization nodes \n  - p1 and p2: generator PolyObjects (p1 for the first part of the interval of the basis function and p2 for the second) These PolyExp objects are shifted along the discretization nodes\n  - BC:        boundary conditions. According to the type of bnoundary conditions, the basis can have N, N-1 or N-2 basis function\n\n\n\n\n\n","category":"function"},{"location":"#FEBULIA.basis_PE","page":"Home","title":"FEBULIA.basis_PE","text":"basis_PE\n\na structure that represents basis functions with `PolyExp` objects \n\n  - N: number of basis functions\n  - xl, xm and xu: arrays containing the lower, intermediate, and upper end of the support of the functions (each of these array have N elements)\n  - p1 and p2: arrays with N PolyExp object representing the basis functions over the respective intervals [xl,xm] and [xm,xu]\n  - v: array of N basis functions \n\nA basis_PE object should be created with the function\n\nbasis_PE(xl::Array{Cdouble,1},xm::Array{Cdouble,1},xu::Array{Cdouble,1},p1::Array{PolyExp,1},p2::Array{PolyExp,1},v::Array{Function,1})\n\n\n\n\n\n","category":"type"},{"location":"#FEBULIA.basis","page":"Home","title":"FEBULIA.basis","text":"basis\n\nWARNING: soon deprecated\n\na structure that contains basis functions \n\n  - N: number of basis functions\n  - X: 2D array containing the lower and upper end of the support of the functions (dim=1: basis function index, dim=2: lower and upper interval ends)\n  - v: array of N basis functions \n\nA basis_PE object should be created with the function\n\nbasis_PE(xl::Array{Cdouble,1},xm::Array{Cdouble,1},xu::Array{Cdouble,1},p1::Array{PolyExp,1},p2::Array{PolyExp,1},v::Array{Function,1})\n\n\n\n\n\n","category":"type"}]
}
